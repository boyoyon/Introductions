<!doctype html>
<html lang="ja">
    <head>
        <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
        <meta charset="utf-8" />
        <title>01</title>
        <style type="text/css">
            p
            {
                padding-left: 2em;
            }
            .margin-large
            {
                margin-left: 30px;
            }
            .margin-large-blue
            {
                margin-left: 30px;
                color: blue;
            }
           .margin-abstract {
               margin-left: 60px; /* 左マージンを広くする */
               margin-right: 60px; /* 右マージンを広くする */
           }
        </style>
    <style>
        .two-columns {
            display: flex;
            flex-direction: row;
            gap: 20px; /* 列間のスペース */
        }
        .column {
            flex: 1; /* 各列が均等に幅を取る */
        }
    </style>
<style>
.three-columns {
  display: flex;
  gap: 10px; /* 列間の余白を設定 */
}
.column {
  flex: 1; /* 各列の幅を均等にする */
  padding: 10px; /* 内側の余白を設定 */
}
</style>
    <style>
        .styleRef { 
            text-indent: -40px; /* 最初の行の字下げを逆方向に */
            margin-left: 10px; /* 2行目以降の字下げを調整 */
            ul {
                  list-style-type: none; /* 箇条書き記号を非表示 */
                  padding-left: 40px; /* 全体の左余白 */
            }
            li {
            }
        }
    </style>
    <style>
        .styleBullet { 
            text-indent: -20px; /* 最初の行の字下げを逆方向に */
            margin-left: 30px; /* 2行目以降の字下げを調整 */
            ul {
                  list-style-type: none; /* 箇条書き記号を非表示 */
                  padding-left: 0px; /* 全体の左余白 */
            }
            li {
            }
        }
    </style>
    <style>
            ol
            {
                margin-left: 30px;
            }
            ul
            {
                margin-left: 30px;
            }
    </style>
    <style>
        .thin-line {
            margin: 0; 
            margin-left:2em;
            border: 0;
            height: 1px;
            background-color: gray;
        }

        .thick-line {
            margin: 0; 
            margin-left:2em;
            border: 0;
            height: 2px;
            background-color: black;
        }
    </style>
    <style>
        .blue {
            color: blue; /* 好きな色に変更してください */
        }
    </style>
    </head>
    <body>
<h1>Lesson 1: Single Systems <span style="color:blue;">単一システム</span></h1>
<p>
This lesson introduces the basic framework of quantum information, including the 
description of quantum states as vectors with complex number entries, measurements 
that allow classical information to be extracted from quantum states, and 
operations on quantum states that are described by unitary matrices. 

<br><span style="color:blue;">
このレッスンでは、量子情報の基本的な枠組みを紹介します。これには、複素数要素を持つベクトルとしての量子状態の記述、量子状態から古典情報を抽出できるようにする測定、ユニタリ行列で記述される量子状態に対する演算などが含まれます。
</span>

</p><p>
We will restrict our attention in this lesson to the comparatively simple setting 
in which a single system is considered in isolation. In the next lesson, we’ll expand 
our view to multiple systems, which can interact with one another and be correlated. 

<br><span style="color:blue;">
このレッスンでは、比較的単純な設定、つまり単一のシステムを単独で扱うことに限定します。次のレッスンでは、複数のシステムが相互作用し、相関関係を持つようになるまで視野を広げます。
</span>

</p>

<h2>1.1 Classical information <span style="color:blue;">古典情報</span></h2>
<p>
To describe quantum information and how it works, we’ll begin with an overview 
of classical information. It is natural to wonder why so much attention is paid 
to classical information in a course on quantum information, but there are good 
reasons. 

<br><span style="color:blue;">
量子情報とその仕組みを説明するために、まず古典情報の概要から始めましょう。量子情報の授業で古典情報になぜこれほど重点が置かれているのか疑問に思うのも当然ですが、それには十分な理由があります。
</span>

</p><p>
For one, although quantum and classical information are different in some spectacular 
ways, their mathematical descriptions are actually quite similar. Classical 
information also serves as a familiar point of reference when studying quantum 
information, as well as a source of analogy that goes a surprisingly long way. It is 
common that people ask questions about quantum information that have natural 
classical analogs, and often those questions have simple answers that can provide 
both clarity and insight into the original questions about quantum information. 
Indeed, it is not at all unreasonable to claim that one cannot truly understand 
quantum information without understanding classical information. 

<br><span style="color:blue;">
第一に、量子情報と古典情報はいくつかの点で大きく異なりますが、数学的な記述は実際には非常に似ています。古典情報は、量子情報を研究する際に馴染みのある参照点として、また驚くほど広範囲にわたる類推の源としても機能します。量子情報に関する疑問が古典情報にも自然に類似していることはよくあり、そうした疑問には単純な答えがあり、量子情報に関する元々の疑問に明確さと洞察を与えることがよくあります。実際、古典情報を理解しなければ量子情報を真に理解することはできないと主張することは、全く不合理ではありません。
</span>

</p><p>
Some readers may already be familiar with the material to be discussed in this 
section, while others may not — but the discussion is meant for both audiences. In 
addition to highlighting the aspects of classical information that are most relevant to 
an introduction to quantum information, this section introduces the Dirac notation, 
which is often used to describe vectors and matrices in quantum information 
and computation. As it turns out, the Dirac notation is not specific to quantum 
information; it can equally well be used in the context of classical information, as 
well as for many other settings in which vectors and matrices arise. 

<br><span style="color:blue;">
このセクションで議論する内容については、既にご存知の読者もいれば、そうでない読者もいるでしょう。しかし、この議論は両方の読者を対象としています。量子情報の入門に最も関連性の高い古典情報の側面を強調することに加えて、このセクションでは、量子情報と計算におけるベクトルと行列の記述によく用いられるディラック記法を紹介します。実は、ディラック記法は量子情報に特有のものではなく、古典情報の文脈でも、ベクトルと行列が出現する他の多くの状況でも同様に使用できます。
</span>

</p>

<h3>Classical states and probability vectors <span style="color:blue;">古典状態と確率ベクトル</span></h3>

<p>
Suppose that we have a system that stores information. More specifically, we shall 
assume that this system can be in one of a finite number of classical states at each 
instant. Here, the term classical state should be understood in intuitive terms, as a 
configuration that can be recognized and described unambiguously. 

<br><span style="color:blue;">
情報を記憶するシステムがあると仮定します。より具体的には、このシステムは各瞬間において有限個の古典状態のいずれかを取り得ると仮定します。ここで「古典状態」という用語は、直感的に理解されるべきであり、明確に認識され、記述できる状態を指します。
</span>

</p><p>
The archetypal example, which we will come back to repeatedly, is that of a 
bit, which is a system whose classical states are 0 and 1. Other examples include 
a standard six-sided die, whose classical states are 1, 2, 3, 4, 5, and 6 (represented 
by the corresponding number of dots on whatever face is on top); a nucleobase 
in a strand of DNA, whose classical states are A, C, G, and T; and a switch on an 
electric fan, whose classical states are (commonly) high, medium, low, and off. In 
mathematical terms, the specification of the classical states of a system are, in fact, 
the starting point: we define a bit to be a system that has classical states 0 and 1, and 
likewise for systems having different classical state sets. 

<br><span style="color:blue;">
繰り返し取り上げる典型的な例は、ビットです。ビットとは、古典的状態が0と1であるシステムです。他の例としては、標準的な6面サイコロ（古典的状態は1、2、3、4、5、6（どの面が上にあるかに対応する点の数で表されます）、DNA鎖中の核酸塩基（古典的状態はA、C、G、T）、扇風機のスイッチ（古典的状態は（一般的に）高、中、低、オフ）などがあります。数学的に言えば、システムの古典的状態の仕様は、実際には出発点です。ビットは古典的状態0と1を持つシステムと定義し、異なる古典的状態セットを持つシステムも同様に定義します。
</span>

</p><p>
For the sake of this discussion, let us give the name \(X\) 
to the system being 
considered, and let us use the symbol \(Σ\) 
to refer to the set of classical states of \(X\). 
In addition to the assumption that \(Σ\) 
is finite, which was already mentioned, we 
naturally assume that \(Σ\) 
is nonempty — for it is nonsensical for a physical system to 
have no states at all. And while it does make sense to consider physical systems 
having infinitely many classical states, we will disregard this possibility, which is 
certainly interesting but is not relevant to this course. For these reasons, and for the 
sake of convenience and brevity, we will hereafter use the term classical state set to 
mean any finite and nonempty set. 

<br><span style="color:blue;">
この議論のために、考察対象の系に \(X\) という名前をつけ、 \(X\) の古典的状態の集合を記号 \(Σ\) で表すことにします。
\(Σ\) が有限であるという仮定（既に述べた）に加えて、\(Σ\) は空でないことも当然仮定します。なぜなら、物理系に状態が全く存在しないというのはナンセンスだからです。物理系が無限個の古典的状態を持つと考えることは理にかなっていますが、この可能性は確かに興味深いものですが、この講義とは関係がないため、ここでは無視します。これらの理由と、便宜上および簡潔にするために、以下では有限かつ空でない集合を意味するために「古典的状態集合」という用語を使用します。
</span>

</p><p>
Here are a few examples: 

<br><span style="color:blue;">
以下にいくつかの例を示します。
</span>

<div class="styleBullet">
<ul><li>
1. If \(X\) is a bit, then \(Σ=\{0, 1\}\). In words, we refer to this set as the binary alphabet.

<br><span style="color:blue;">
\(X\) がビットの場合、\(Σ=\{0, 1\}\) となります。この集合を言葉で表すと、2進アルファベットと呼ばれます。
</span>

</li><br><li>
2. If \(X\) is a six-sided die, then \(Σ=\{1, 2, 3, 4, 5, 6\}\). 

<br><span style="color:blue;">
\(X\) が6面サイコロの場合、\(Σ=\{1, 2, 3, 4, 5, 6\}\) となります。
</span>

</li><br><li>
3. If \(X\) is an electric fan switch, then \(Σ=\{high, medium, low, off\}\). 

<br><span style="color:blue;">
\(X\) が扇風機のスイッチの場合、\(Σ=\{高、中、低、オフ\}\) となります。
</span>

</li></ul></div>

</p><p>
When thinking about \(X\) 
as a carrier of information, the different classical states 
of \(X\) 
could be assigned certain meanings, leading to different outcomes or consequences. 
In such cases, it may be sufficient to describe \(X\) 
as simply being in one of 
its possible classical states. For instance, if \(X\) 
is a fan switch, we might happen to 
know with certainty that it is set to high, which might then lead us to switch it to 
medium. 

<br><span style="color:blue;">
\(X\) を情報の担い手として考えると、\(X\) の様々な古典的状態に特定の意味が割り当てられ、異なる結果や帰結につながる可能性があります。そのような場合、\(X\) が可能な古典的状態のいずれかにあると記述するだけで十分な場合があります。例えば、\(X\) が扇風機のスイッチだとすると、それが強に設定されていることを確実に知ることができ、その結果、中に切り替えることになるかもしれません。
</span>

</p><p>
Often in information processing, however, our knowledge is uncertain. One 
way to represent our knowledge of the classical state of a system \(X\) 
is to associate 
probabilities with its different possible classical states, resulting in what we shall call 
a probabilistic state. 

<br><span style="color:blue;">
しかし、情報処理においては、しばしば私たちの知識は不確実です。システム \(X\) の古典的状態に関する知識を表現する一つの方法は、様々な可能な古典的状態に確率を関連付けることです。その結果得られるのは、確率的状態です。
</span>

</p><p>
For example, suppose \(X\) 
is a bit. Based on what we know or expect about 
what has happened to \(X\) 
in the past, we might perhaps believe that \(X\) 
is in the 
classical state 0 with probability 3/4 and in the state 1 with probability 1/4. We 
may represent these beliefs by writing this: 

<br><span style="color:blue;">
例えば、\(X\) がビットであるとします。\(X\) に過去に何が起こったかについての知識や予想に基づいて、\(X\) が古典状態 0 にある確率は 3/4、状態 1 にある確率は 1/4 であると信じるかもしれません。これらの信念は次のように表すことができます。
</span>

\[
Pr(X = 0)=\frac{3}{4}　and　Pr(X=1) = \frac{1}{4}
\]

A more succinct way to represent this probabilistic state is by a column vector. 

<br><span style="color:blue;">
この確率状態をより簡潔に表す方法は、列ベクトルを使用することです。
</span>

\[
\begin{pmatrix}
\frac{3}{4} \\
\frac{1}{4}
\end{pmatrix}
\]

The probability of the bit being 0 is placed at the top of the vector and the probability 
of the bit being 1 is placed at the bottom, because this is the conventional way to 
order the set {0, 1}. 

<br><span style="color:blue;">
ビットが0である確率はベクトルの先頭に配置され、ビットが1である確率は末尾に配置されます。これは、集合{0, 1}を順序付ける従来の方法だからです。
</span>

</p><p>
In general, we can represent a probabilistic state of a system having any classical 
state set in the same way, as a vector of probabilities. The probabilities can be 
ordered in any way we choose, but it is typical that there is a natural or default way 
to do this. To be precise, we can represent any probabilistic state through a column 
vector satisfying two properties: 

<br><span style="color:blue;">
一般に、任意の古典的状態集合を持つシステムの確率状態は、確率のベクトルとして同様に表現できます。確率は任意の順序に並べることができますが、通常は自然な、あるいはデフォルトの方法があります。正確に言うと、任意の確率状態は、次の2つの性質を満たす列ベクトルで表現できます。
</span>

<div class="styleBullet">
<ul><li>
1. All entries of the vector are nonnegative real numbers. 

<br><span style="color:blue;">
ベクトルのすべての要素は非負の実数です。
</span>

</li><br><li>
2. The sum of the entries is equal to 1. 

<br><span style="color:blue;">
エントリの合計は 1 になります。
</span>

</li></ul></div>
</p><p>

Conversely, any column vector that satisfies these two properties can be taken as 
a representation of a probabilistic state. Hereafter, we will refer to vectors of this 
form as probability vectors. 

<br><span style="color:blue;">
逆に、これら2つの性質を満たす任意の列ベクトルは、確率状態を表すものとして捉えることができます。以下では、この形式のベクトルを確率ベクトルと呼びます。
</span>

</p><p>
Alongside the succinctness of this notation, identifying probabilistic states as 
column vectors has the advantage that operations on probabilistic states are represented 
through matrix-vector multiplication, as will be discussed shortly. 

<br><span style="color:blue;">
この表記法の簡潔さに加えて、確率状態を列ベクトルとして識別することには、確率状態に対する演算が行列ベクトルの乗算によって表現されるという利点があります。これについては後ほど説明します。
</span>

</p>

<h3>Measuring probabilistic states <span style="color:blue;">確率状態の測定</span></h3>

<p>
Next let us consider what happens if we measure a system when it is in a probabilistic 
state. In this context, by measuring a system we simply mean that we look at the 
system and recognize whatever classical state it is in without ambiguity. Intuitively 
speaking, we can’t “see” a probabilistic state of a system; when we look at it, we 
just see one of the possible classical states. 

<br><span style="color:blue;">
次に、確率状態にある系を測定するとどうなるかを考えてみましょう。ここで「系を測定する」とは、系を観察し、それがどのような古典的状態にあるかを曖昧さなく認識することを意味します。直感的に言えば、系の確率的状態を「見る」ことはできません。系を観察するとき、私たちは起こり得る古典的状態の一つを見ているだけなのです。
</span>

</p><p>
By measuring a system, we may also change our knowledge of it, and therefore 
the probabilistic state we associate with it can change. That is, if we recognize that \(X\) is in the classical state \(a ∈ Σ\), then the new probability vector representing our 
knowledge of the state of \(X\) 
becomes the vector having a 1 in the entry corresponding 
to a and 0 for all other entries. This vector indicates that \(X\) 
is in the classical state a 
with certainty — which we know having just recognized it — and we denote this 
vector by \(|a\rangle\), which is read as “ket a” for a reason that will be explained shortly. 
Vectors of this sort are also called standard basis vectors. 

<br><span style="color:blue;">
系を測定することで、その系に関する知識も変化する可能性があり、したがって、系に関連付ける確率状態も変化する可能性があります。つまり、\(X\) が古典状態 \(a ∈ Σ\) にあることを認識した場合、\(X\) の状態に関する知識を表す新しい確率ベクトルは、a に対応する要素に 1 を、その他の要素に 0 を持つベクトルになります。このベクトルは、\(X\) が古典状態 a にあることを確実に示しており、これは私たちが認識した時点で既に分かっていることです。このベクトルを \(|a\rangle\) と表記します。これは「ケット a」と読みますが、その理由は後ほど説明します。この種のベクトルは標準基底ベクトルとも呼ばれます。
</span>

</p><p>
For example, assuming that the system we have in mind is a bit, the standard 
basis vectors are given by 

<br><span style="color:blue;">
例えば、我々が考えているシステムがビットであると仮定すると、標準的な基底ベクトルは次のように与えられる。
</span>

\[
|0\rangle = 
\begin{pmatrix}
1 \\
0
\end{pmatrix}
　and　
|1\rangle =
\begin{pmatrix}
0 \\
1
\end{pmatrix}
\]

Notice that any two-dimensional column vector can be expressed as a linear combination 
of these two vectors. For example, 

<br><span style="color:blue;">
任意の2次元列ベクトルは、これら2つのベクトルの線形結合として表現できることに注目してください。例えば、
</span>

\[
\begin{pmatrix}
\frac{3}{4} \\
\frac{1}{4}
\end{pmatrix}
=\frac{3}{4}|0\rangle + \frac{1}{4}|1\rangle
\]

This fact naturally generalizes to any classical state set: any column vector can be 
written as a linear combination of standard basis states. Quite often we express 
vectors in precisely this way. 

<br><span style="color:blue;">
この事実は、あらゆる古典的な状態集合に自然に一般化されます。つまり、任意の列ベクトルは、標準的な基底状態の線形結合として表すことができます。私たちはしばしば、まさにこのようにベクトルを表現します。
</span>

</p><p>
Returning to the change of a probabilistic state upon being measured, we may 
note the following connection to our everyday experiences. Suppose we flip a 
fair coin, but cover up the coin before looking at it. We would then say that its 
probabilistic state is 

<br><span style="color:blue;">
測定されたときの確率的状態の変化について考えてみると、私たちの日常の経験との次のような関連性に気づくかもしれません。公平なコインを投げるが、見る前にコインを隠したとします。その場合、その確率的状態は
</span>

\[
\begin{pmatrix}
\frac{1}{2} \\
\frac{1}{2}
\end{pmatrix}
=\frac{1}{2}|head\rangle+\frac{1}{2}|tail\rangle
\]

Here, the classical state set of our coin is {heads, tails}. We’ll choose to order these 
states as heads first, tails second. 

<br><span style="color:blue;">
ここで、コインの典型的な状態集合は{表、裏}です。これらの状態を表、裏の順に並べることにします。
</span>

\[
|head\rangle =
\begin{pmatrix}
1 \\
0
\end{pmatrix}
　|tail\rangle=
\begin{pmatrix}
0 \\
1
\end{pmatrix}
\]

</p><p>
If we were to uncover the coin and look at it, we would see one of the two 
classical states: heads or tails. Supposing that the result were tails, we would 
naturally update our description of the probabilistic state of the coin so that it 
becomes |tails⟩. Of course, if we were then to cover up the coin, and then uncover 
it and look at it again, the classical state would still be tails, which is consistent with 
the probabilistic state being described by the vector |tails⟩. 

<br><span style="color:blue;">
コインの覆いを取り除くと、表か裏という2つの古典的な状態のいずれかが見えるでしょう。結果が裏だったと仮定すると、コインの確率的状態の記述は自然に「|裏⟩」となるように更新されます。もちろん、その後コインを覆い隠してから再び覆いを取ると、古典的な状態は依然として裏であり、これは確率的状態がベクトル「|裏⟩」で記述されることと整合しています。
</span>

</p><p>
This may seem trivial, and in some sense it is. However, while quantum systems 
behave in an entirely analogous way, their measurement properties are frequently 
considered strange or unusual. By establishing the analogous properties of classical 
systems, the way quantum information works might seem less unusual. 

<br><span style="color:blue;">
これは些細なことのように思えるかもしれませんし、ある意味ではそうかもしれません。しかし、量子系は全く類似した振る舞いをするにもかかわらず、その測定特性はしばしば奇妙、あるいは異常だと見なされます。古典系における類似した特性を確立することで、量子情報の仕組みはそれほど異常ではないように思えるかもしれません。
</span>

</p><p>
One final remark concerning measurements of probabilistic states is this: probabilistic 
states describe knowledge or belief, not necessarily something actual, and 
measuring merely changes our knowledge and not the system itself. For instance, 
the state of a coin after we flip it, but before we look, is either heads or tails — we 
just don’t know which until we look. Upon seeing that the classical state is tails, say, 
we would naturally update the vector describing our knowledge to |tails⟩, but to 
someone else who didn’t see the coin when it was uncovered, the probabilistic state 
would remain unchanged. This is not a cause for concern; different individuals may 
have different knowledge or beliefs about a particular system, and hence describe 
that system by different probability vectors. 

<br><span style="color:blue;">
確率状態の測定に関する最後の注意点は次のとおりです。確率状態は知識や信念を記述するものであり、必ずしも実際の何かを表すものではありません。測定によって知識が変化するだけで、システム自体が変化するわけではありません。例えば、コインを投げた後、見るまでは表か裏のどちらかの状態です。見るまではどちらかがわからないだけです。例えば、古典的な状態が裏であるとわかれば、私たちは当然、自分の知識を記述するベクトルを|裏⟩⟩に更新しますが、コインが裏になったときに見ていなかった他の人にとっては、確率状態は変化しません。これは懸念すべきことではありません。異なる個人が特定のシステムについて異なる知識や信念を持っている可能性があり、したがって、そのシステムを異なる確率ベクトルで記述する可能性があるからです。
</span>
</p>

<h3>Classical operations <span style="color:blue;">古典的な操作</span></h3>

<p>
In the last part of this brief summary of classical information, we will consider the 
sorts of operations that can be performed on a classical system. 

<br><span style="color:blue;">
古典的情報のこの短い要約の最後の部分では、古典的システムで実行できる操作の種類について考えます。
</span>

</p>

<h3>Deterministic operations <span style="color:blue;">決定論的な操作</span></h3>

<p>
First, there are deterministic operations, where each classical state \(a ∈ 
Σ\) is transformed into \(f(a)\) for some function f of the form \(f : Σ 
→ Σ\).

<br><span style="color:blue;">
まず、決定論的な操作があり、そこでは各古典的状態 \(a ∈
Σ\) が、形式 \(f : Σ
→ Σ\) の何らかの関数 f に対して \(f(a)\) に変換されます。
</span>

</p><p> 
For example, if \(Σ=\{0, 1\}\), there are four functions of this form, \(f_1, f_2, f_3,\) and \(f_4\), which can be represented by tables of values as follows: 

<br><span style="color:blue;">
たとえば、\(Σ=\{0, 1\}\) の場合、この形式の関数は \(f_1, f_2, f_3,\)、\(f_4\) の 4 つあり、これらは次の値の表で表すことができます。
</span>

\[
\begin{array}{c|c}
a & f_1(a) \\
\hline
0 & 0 \\
1 & 0
\end{array}
　　
\begin{array}{c|c}
a & f_2(a) \\
\hline
0 & 0 \\
1 & 1
\end{array}
　　
\begin{array}{c|c}
a & f_3(a) \\
\hline
0 & 1 \\
1 & 0
\end{array}
　　
\begin{array}{c|c}
a & f_4(a) \\
\hline
0 & 1 \\
1 & 1
\end{array}
\]

The first and last of these functions are constant: \(f_1(a)= 
0\) and \(f_4(a)=1\) for each 
\(a ∈ Σ\). The middle two are not constant, they are balanced: each of the two output 
values occurs the same number of times (once, in this case) as we range over the 
possible inputs. The function \(f_2\) is the identity function: \(f_2(a)= a\) for each \(a ∈ Σ\). 
And \(f_3\) is the function \(f_3(0)= 1\) and \(f_3(1)=0\), which is better-known as the NOT function. 

<br><span style="color:blue;">
これらの関数の最初と最後は定数です。\(a ∈ Σ\) ごとに \(f_1(a)= 0\) と \(f_4(a)=1\) です。真ん中の2つは定数ではなく、バランスが取れています。つまり、2つの出力値はそれぞれ、可能な入力をすべて調べる際に同じ回数（この場合は1回）発生します。関数 \(f_2\) は恒等関数です。\(a ∈ Σ\) ごとに \(f_2(a)= a\) です。
そして \(f_3\) は関数 \(f_3(0)= 1\) かつ \(f_3(1)=0\) であり、NOT関数としてよく知られています。
</span>

</p><p>
The actions of deterministic operations on probabilistic states can be represented 
by matrix-vector multiplication. Specifically, the matrix M that represents a given 
function \(f :Σ→Σ\) is the one that satisfies 

<br><span style="color:blue;">
確率的状態に対する決定論的操作の作用は、行列ベクトルの積で表すことができます。具体的には、与えられた関数 \(f :Σ→Σ\) を表す行列 M は、次式を満たす行列です。
</span>

\[
M|a\rangle = |f(a)\rangle 
\]

for every \(a ∈ Σ\). Such a matrix always exists and is uniquely determined by this 
requirement. Matrices that represent deterministic operations always have exactly 
one 1 in each column, and 0 for all other entries. 

<br><span style="color:blue;">
すべての \(a ∈ Σ\) に対して、そのような行列は常に存在し、この要件によって一意に決定されます。決定論的な演算を表す行列は、各列に必ず1つだけ1が含まれ、その他の要素は0になります。
</span>

</p><p>
For instance, the matrices \(M_1,...,M_4\) corresponding to the functions \(f_1,...,f_4\) above are as follows: 

<br><span style="color:blue;">
たとえば、上記の関数 \(f_1,...,f_4\) に対応する行列 \(M_1,...,M_4\) は次のようになります。
</span>

\[
M_1 = 
\begin{pmatrix}
1 & 1 \\
0 & 0
\end{pmatrix}
,　M_2=
\begin{pmatrix}
1 & 0 \\
0 & 1
\end{pmatrix}
,　M_3=
\begin{pmatrix}
0 & 1 \\
1 & 0
\end{pmatrix}
,　M_4=
\begin{pmatrix}
0 & 0 \\
1 & 1
\end{pmatrix}
\]

Here’s a quick verification showing that the first matrix is correct. The other three 
can be checked similarly. 

<br><span style="color:blue;">
最初の行列が正しいことを示す簡単な検証を以下に示します。他の3つも同様に確認できます。
</span>

\[
\begin{align}
M_1|0\rangle &=
\begin{pmatrix}
1 & 1 \\
0 & 0
\end{pmatrix}
\begin{pmatrix}
1 \\
0
\end{pmatrix}
=
\begin{pmatrix}
1 \\
0
\end{pmatrix}
=|0\rangle=|f_1(0)\rangle \\

\\

M_1|1\rangle &=
\begin{pmatrix}
1 & 1 \\
0 & 0
\end{pmatrix}
\begin{pmatrix}
0 \\
1
\end{pmatrix}
=
\begin{pmatrix}
1 \\
0
\end{pmatrix}
=|0\rangle=|f_1(1)\rangle 
\end{align}
\]

</p><p>
A convenient way to represent matrices of these and other forms makes use 
of an analogous notation for row vectors to the one for column vectors discussed 
previously: we denote by \(\langle a|\) the row vector having a 1 in the entry corresponding 
to a and zero for all other entries, for each \(a ∈ Σ. This vector is read as “bra a.” 

<br><span style="color:blue;">
これらの行列やその他の形式の行列を表す便利な方法は、前述の列ベクトルの表記法と同様の表記法を行ベクトルにも用いることです。\(a ∈ Σ ごとに、a に対応する要素が 1 で、その他の要素が 0 である行ベクトルを \(\langle a|\) と表記します。このベクトルは「bra a」と読みます。
</span>

</p><p>
For example, if \(Σ=\{0, 1\}\), then 

<br><span style="color:blue;">
例えば\(Σ=\{0, 1\}\)の場合、
</span>

\[
\langle 0|=
\begin{pmatrix}
1 & 0
\end{pmatrix}
　and　\langle 1|=
\begin{pmatrix}
0 & 1
\end{pmatrix}
\]

</p><p>
For any classical state set \(Σ\), we can view row vectors and column vectors as 
matrices, and perform the matrix multiplication \(|b\rangle\langle a|\). We obtain a square matrix 
having a 1 in the entry corresponding to the pair \((b, a)\), meaning that the row of 
the entry corresponds to the classical state b and the column corresponds to the 
classical state \(a\), with 0 for all other entries. For example, 

<br><span style="color:blue;">
任意の古典的状態集合 \(Σ\) について、行ベクトルと列ベクトルを行列と見なし、行列乗算 \(|b\rangle\langle a|\) を実行することができます。これにより、\((b, a)\) に対応する要素に 1 を持つ正方行列が得られます。これは、その要素の行が古典的状態 b に対応し、列が古典的状態 \(a\) に対応し、その他の要素は 0 であることを意味します。例えば、
</span>

\[
|0\rangle\langle 1| =
\begin{pmatrix}
1 \\
0
\end{pmatrix}
\begin{pmatrix}
0 & 1
\end{pmatrix}
=
\begin{pmatrix}
0 & 1 \\
0 & 0
\end{pmatrix}
\]

</p><p>
Using this notation, we may express the matrix \(M\) that corresponds to any given 
function \(f : Σ→Σ\) as

<br><span style="color:blue;">
この表記法を用いると、任意の関数 \(f : Σ→Σ\) に対応する行列 \(M\) は次のように表せる。
</span>

\[ 
M =\sum_{a\in \Sigma} |f(a)\rangle\langle a|
\]
 
For example, consider the function \(f_4\) above, for which \(Σ=\{0, 1\}\). We obtain the matrix 

<br><span style="color:blue;">
例えば、\(Σ=\{0, 1\}\)となる関数\(f_4\)を考えてみましょう。すると、次の行列が得られます。
</span>

\[
M_4=|f_4(0)\rangle\langle 0|+|f_4(1)\rangle\langle 1|
=|1\rangle\langle 0|+|1\rangle\langle 1|
=
\begin{pmatrix}
0 & 0 \\
1 & 0
\end{pmatrix}
+
\begin{pmatrix}
0 & 0 \\
0 & 1
\end{pmatrix}
=
\begin{pmatrix}
0 & 0 \\
1 & 1
\end{pmatrix}
\]

</p><p>
The reason why this works is as follows. If we again think about vectors as 
matrices, and this time consider the multiplication \(\langle a||b\rangle\), we obtain a 1 × 1 matrix, 
which we can think about as a scalar (i.e., a number). For the sake of tidiness, we 
write this product as \(\langle a|b\rangle\) rather than \(\langle a||b\rangle\). This product satisfies the following 
simple formula. 

<br><span style="color:blue;">
これがうまくいく理由は次のとおりです。ベクトルを行列として考え、今度は乗算 \(\langle a||b\rangle\) を考えると、1 × 1 行列が得られます。これはスカラー（つまり、数値）として考えることができます。簡潔にするために、この積は \(\langle a||b\rangle\) ではなく \(\langle a||b\rangle\) と書きます。この積は次の簡単な式を満たします。
</span>

\[
\langle a|b\rangle =
\begin{cases}
1 & a=b \\
\\
0 & a \neq b
\end{cases}
\]

Using this observation, together with the fact that matrix multiplication is associative and linear, we obtain 

<br><span style="color:blue;">
この観察と、行列の乗算が結合的かつ線形であるという事実を組み合わせると、次の式が得られます。
</span>

\[
M|b\rangle = \left(\sum_{a\in\Sigma} |f(a)\rangle\langle a|\right)|b\rangle =
\sum_{a\in\Sigma} |f(a)\rangle\langle a|b\rangle = |f(b)\rangle
\]

for each \(b ∈ Σ\), which is precisely what we require of the matrix \(M\). 

<br><span style="color:blue;">
各 \(b ∈ Σ\) に対して、これはまさに行列 \(M\) に要求されるものです。
</span>

</p><p>
As we will discuss in greater detail later in a later lesson, \(\langle a|b\rangle\) may also be seen 
as an inner product between the vectors \(|a\rangle\) and \(|b\rangle\). Inner products are critically 
important in quantum information, but we’ll delay a discussion of them until they 
are needed. 

<br><span style="color:blue;">
後のレッスンでより詳しく説明しますが、\(\langle a|b\rangle\) はベクトル \(|a\rangle\) と \(|b\rangle\) の内積と見なすこともできます。内積は量子情報において非常に重要ですが、必要になるまで説明を延ばします。
</span>

</p><p>
At this point the names “bra” and “ket” may be evident: putting a “bra” \(\langle a|\) together with a “ket” \(|b\rangle\) yields a “bracket” \(\langle a|b\rangle\). This notation and terminology is 
due to Paul Dirac, and for this reason is known as the Dirac notation. 

<br><span style="color:blue;">
この時点で「ブラ」と「ケット」という名前が明らかになるかもしれません。「ブラ」\(\langle a|\) と「ケット」\(|b\rangle\) を組み合わせると「ブラケット」\(\langle a|b\rangle\) になります。この表記法と用語はポール・ディラックに由来し、そのためディラック表記法として知られています。
</span>

</p>

<h3>Probabilistic operations and stochastic matrices <span style="color:blue;">確率的演算と確率行列</span></h3>

<p>
In addition to deterministic operations, we have probabilistic operations. 

<br><span style="color:blue;">
決定論的な操作に加えて、確率的な操作もあります。
</span>

</p><p>
For example, consider the following operation on a bit. If the classical state of 
the bit is 0, it is left alone; and if the classical state of the bit is 1, it is flipped, so 
that it becomes 0 with probability 1/2 and 1 with probability 1/2. This operation is 
represented by the matrix 

<br><span style="color:blue;">
例えば、ビットに対する次の操作を考えてみましょう。ビットの古典的状態が0の場合はそのままにしておきます。ビットの古典的状態が1の場合は反転し、確率1/2で0になり、確率1/2で1になります。この操作は、次の行列で表されます。
</span>

\[
\begin{pmatrix}
1 & \frac{1}{2} \\
0 & \frac{1}{2}
\end{pmatrix}
\]

One can check that this matrix does the correct thing by multiplying the two 
standard basis vectors by it. 

<br><span style="color:blue;">
この行列が正しい動作をしているかどうかは、2つの標準基底ベクトルをこれに掛け合わせることで確認できます。
</span>

</p><p>
For an arbitrary choice of a classical state set, we can describe the set of all 
probabilistic operations in mathematical terms as those that are represented by 
stochastic matrices, which are matrices satisfying these two properties: 

<br><span style="color:blue;">
古典的な状態集合を任意に選択すると、すべての確率操作の集合を数学的に記述することができ、確率行列で表されるものとして表すことができます。確率行列は次の2つの特性を満たします。
</span>

<div class="styleBullet">
<ul><li>
1. All entries are nonnegative real numbers. 

<br><span style="color:blue;">
すべてのエントリは非負の実数です。
</span>

</li><br><li>
2. The entries in every column sum to 1. 

<br><span style="color:blue;">
各列のエントリの合計は 1 になります。
</span>

</li></ul></div>
</p><p>
Equivalently, stochastic matrices are matrices whose columns all form probability 
vectors. 

<br><span style="color:blue;">
同様に、確率行列とは、すべての列が確率ベクトルを形成する行列です。
</span>

</p><p>
We can think about probabilistic operations at an intuitive level as ones where 
randomness might somehow be used or introduced during the operation, just 
like in the example above. With respect to the stochastic matrix description of a 
probabilistic operation, each column can be viewed as a vector representation of 
the probabilistic state that is generated given the classical state input corresponding 
to that column. 

<br><span style="color:blue;">
確率的演算は、直感的に言えば、上記の例のように、演算中に何らかの形でランダム性が利用または導入される演算と考えることができます。確率的演算の確率行列記述に関して言えば、各列は、その列に対応する古典的な状態入力が与えられた場合に生成される確率的状態のベクトル表現と見なすことができます。
</span>

</p><p>
We can also think about stochastic matrices as being exactly those matrices that 
always map probability vectors to probability vectors. That is, stochastic matrices 
always map probability vectors to probability vectors, and any matrix that always 
maps probability vectors to probability vectors must be a stochastic matrix. 

<br><span style="color:blue;">
確率行列とは、確率ベクトルを常に確率ベクトルに写像する行列であると考えることもできます。つまり、確率行列は確率ベクトルを常に確率ベクトルに写像し、確率ベクトルを常に確率ベクトルに写像する行列は必ず確率行列です。
</span>

</p><p>
Finally, a different way to think about probabilistic operations is that they are 
random choices of deterministic operations. For instance, we can think about the 
operation in the example above as applying either the identity function or the 
constant 0 function, each with probability 1/2. This is consistent with the equation 

<br><span style="color:blue;">
最後に、確率的演算を別の視点から考えると、それらは決定論的演算のランダムな選択であると言えます。例えば、上記の例の演算は、恒等関数または定数0関数のいずれかを、それぞれ確率1/2で適用するものと考えることができます。これは、次の式と一致します。
</span>

\[
\begin{pmatrix}
1 & \frac{1}{2} \\
0 & \frac{1}{2}
\end{pmatrix}
=\frac{1}{2}
\begin{pmatrix}
1 & 0 \\
0 & 1
\end{pmatrix}
+\frac{1}{2}
\begin{pmatrix}
1 & 1 \\
0 & 0
\end{pmatrix}
\]

Such an expression is always possible, for an arbitrary choice of a classical state set 
and any stochastic matrix having rows and columns identified with it. 

<br><span style="color:blue;">
このような表現は、任意の古典的状態集合と、それに対応する行と列を持つ任意の確率行列に対して常に可能です。
</span>

</p>

<h3>Compositions of probabilistic operations <span style="color:blue;">確率的演算の合成</span></h3>

<p>
Suppose that \(X\) 
is a system having classical state set \(Σ\,\) and \(M_1,...,M_n\) are stochastic 
matrices representing probabilistic operations on the system \(X\). 

<br><span style="color:blue;">
\(X\) は古典的状態集合 \(Σ\,\) を持つシステムであり、\(M_1,...,M_n\) はシステム \(X\) に対する確率的操作を表す確率行列であるとする。
</span>

</p><p>
If the first operation \(M_1\) is applied to the probabilistic state represented by a 
probability vector \(u\), the resulting probabilistic state is represented by the vector 
\(M_1u\). If we then apply the second probabilistic operation \(M_2\) to this new probability 
vector, we obtain the probability vector 

<br><span style="color:blue;">
最初の演算 \(M_1\) を確率ベクトル \(u\) で表される確率状態に適用すると、結果として得られる確率状態はベクトル \(M_1u\) で表される。次に、この新しい確率ベクトルに2番目の確率演算 \(M_2\) を適用すると、確率ベクトルが得られる。
</span>

\[
M_2(M_1u)=(M_2 M_1)u
\]

The equality follows from the fact that matrix multiplication, including matrix-
vector multiplication as a special case, is an associative operation. Thus, the probabilistic 
operation obtained by composing the first and second probabilistic operations, 
where we first apply \(M_1\) and then apply \(M_2\), is represented by the matrix 
\(M_2 M_1\), which is necessarily stochastic. 

<br><span style="color:blue;">
この等式は、行列乗算（特別なケースとして行列ベクトル乗算を含む）が結合演算であるという事実から導かれる。したがって、最初に \(M_1\) を適用し、次に \(M_2\) を適用する最初の確率演算と2番目の確率演算を合成して得られる確率演算は、必然的に確率的な行列 \(M_2 M_1\) で表わされる。
</span>

</p><p>
More generally, composing the probabilistic operations represented by the matrices 
\(M_1,...,M_n\) in this order, meaning that \(M_1\) is applied first, \(M_2\) is applied second, 
and so on, with \(M_n\) applied last, is represented by the matrix product 

<br><span style="color:blue;">
より一般的には、行列\(M_1,...,M_n\)で表される確率演算をこの順序で、つまり\(M_1\)が最初に適用され、\(M_2\)が2番目に適用され、
\(M_n\)が最後に適用されるという順序で合成すると、行列積で表される。
</span>

\[
M_n ···M_1
\] 

Note that the ordering is important here: although matrix multiplication is associative, 
it is not a commutative operation. For example, if 

<br><span style="color:blue;">
ここで順序が重要であることに注意してください。行列の乗算は結合的ですが、可換ではありません。例えば、
</span>

\[
M_1=
\begin{pmatrix}
1 & 1 \\
0 & 0
\end{pmatrix}
　and　M_2=
\begin{pmatrix}
0 & 1 \\
1 & 0
\end{pmatrix}
\]

then

<br><span style="color:blue;">
そうすると
</span>

\[
M_2M_1 =
\begin{pmatrix}
0 & 0 \\
1 & 1
\end{pmatrix}
　and　M_1M_2=
\begin{pmatrix}
1 & 1 \\
0 & 0
\end{pmatrix}
\]

That is, the order in which probabilistic operations are composed matters; changing 
the order in which operations are applied in a composition can change the resulting 
operation. 

<br><span style="color:blue;">
つまり、確率的演算が合成される順序が重要であり、合成において演算が適用される順序を変更すると、結果の演算が変化する可能性があります。
</span>

</p>

<h2>1.2 Quantum information <span style="color:blue;">量子情報</span></h2>
<p>
Now we’re ready to move on to quantum information, where we make a different 
choice for the type of vector that represents a state — in this case a quantum state 
— of the system being considered. Like in the previous discussion of classical 
information, we’ll be concerned with systems having finite and nonempty sets of 
classical states, and we’ll make use of much of the same notation. 

<br><span style="color:blue;">
さて、量子情報に移る準備が整いました。ここでは、対象とするシステムの状態（この場合は量子状態）を表すベクトルの種類を別の方法で選択します。前回の古典情報の説明と同様に、古典状態の有限かつ空でない集合を持つシステムを扱い、ほぼ同じ表記法を使用します。
</span>

</p>

<h3>Quantum state vectors <span style="color:blue;">量子状態ベクトル</span></h3>
<p>
A quantum state of a system is represented by a column vector, similar to a probabilistic 
state. As before, the indices of the vector label the classical states of the system. 
Vectors representing quantum states are characterized by these two properties: 

<br><span style="color:blue;">
系の量子状態は、確率状態と同様に、列ベクトルで表されます。前述のように、ベクトルの添え字は系の古典状態を表します。量子状態を表すベクトルは、以下の2つの特性によって特徴付けられます。
</span>

<div class="styleBullet">
<ul><li>
1. The entries of a quantum state vector are complex numbers. 

<br><span style="color:blue;">
量子状態ベクトルの要素は複素数です。
</span>

</li><br><li>
2. The sum of the absolute values squared of the entries of a quantum state vector is 1. 

<br><span style="color:blue;">
量子状態ベクトルのエントリの絶対値の二乗の合計は 1 です。
</span>

</li></ul></div>
</p><p>

Thus, in contrast to probabilistic states, vectors representing quantum states 
need not have nonnegative real number entries, and it is the sum of the absolute 
values squared of the entries (as opposed to the sum of the entries) that must equal 1. 
Simple as these changes are, they give rise to the differences between quantum and 
classical information; any speedup from a quantum computer, or improvement 
from a quantum communication protocol, is ultimately derived from these simple 
mathematical changes. 

<br><span style="color:blue;">
したがって、確率状態とは対照的に、量子状態を表すベクトルは非負の実数要素を持つ必要はなく、要素の合計ではなく、要素の絶対値の二乗の合計が1に等しくなければなりません。これらの変更は単純ですが、量子情報と古典情報の違いを生み出します。量子コンピュータの高速化や量子通信プロトコルの改善は、最終的にはこれらの単純な数学的変更から生まれます。
</span>

</p><p>
The Euclidean norm of a column vector 

<br><span style="color:blue;">
列ベクトルのユークリッドノルム
</span>

\[
v=
\begin{pmatrix}
\alpha_1 \\
\vdots \\
\alpha_n
\end{pmatrix}
\]

is denoted and defined as follows: 

<br><span style="color:blue;">
は次のように表記および定義されます。
</span>

\[
||v||=\sqrt{\sum_{k=1}^n |\alpha_k|^2}
\]

The condition that the sum of the absolute values squared of a quantum state vector 
equals 1 is therefore equivalent to that vector having Euclidean norm equal to 1. 
That is, quantum state vectors are unit vectors with respect to the Euclidean norm. 

<br><span style="color:blue;">
したがって、量子状態ベクトルの絶対値の二乗の和が1になるという条件は、そのベクトルのユークリッドノルムが1であることと等価です。
つまり、量子状態ベクトルはユークリッドノルムに関して単位ベクトルです。
</span>

</p>

<h3>Examples of qubit states <span style="color:blue;">量子ビットの状態の例</span></h3>
<p>
The term qubit refers to a quantum system whose classical state set is {0, 1}. That is, 
a qubit is really just a bit — but by using this name we explicitly recognize that this 
bit can be in a quantum state. 

<br><span style="color:blue;">
量子ビットという用語は、古典的状態集合が{0, 1}である量子系を指します。つまり、量子ビットは実際には単なるビットですが、この名称を使用することで、このビットが量子状態になり得ることを明示的に認識します。
</span>

</p><p>
These are examples of quantum states of a qubit: 

<br><span style="color:blue;">
これらは量子ビットの量子状態の例です。
</span>

\[
\begin{align}
\begin{pmatrix}
1 \\
0
\end{pmatrix}
= |0\rangle　and　
\begin{pmatrix}
0 \\
1
\end{pmatrix}
=|1\rangle \\
\\
\begin{pmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{pmatrix}
=\frac{1}{\sqrt{2}}|0\rangle+\frac{1}{\sqrt{2}}|1\rangle \\
\\
\begin{pmatrix}
\frac{1+2i}{3} \\
-\frac{2}{3}
\end{pmatrix}
~\frac{1+2i}{3}|0\rangle-\frac{2}{3}|1\rangle
\end{align}
\tag{1.1}
\]

The first two examples, \(|0\rangle\) and \(|1\rangle\), illustrate that standard basis elements 
are valid quantum state vectors. Their entries are complex numbers, where the 
imaginary part of these numbers all happen to be 0, and computing the sum of the 
absolute values squared of the entries yields 

<br><span style="color:blue;">
最初の2つの例、\(|0\rangle\) と \(|1\rangle\) は、標準的な基底元が有効な量子状態ベクトルであることを示しています。これらの要素は複素数で、これらの数の虚数部はすべて0であり、要素の絶対値の2乗の和を計算すると、次のようになります。
</span>

\[
|1|^2 +|0|^2 =1　and　|0|^2 +|1|^2 =1
\]
 
as required. Similar to the classical setting, we associate the quantum state vectors \(|0\rangle\) and \(|1\rangle\) with a qubit being in the classical state 0 and 1, respectively. 

<br><span style="color:blue;">
必要に応じて。古典的な設定と同様に、量子状態ベクトル \(|0\rangle\) と \(|1\rangle\) を、それぞれ古典状態 0 と 1 にある量子ビットに関連付けます。
</span>

</p><p>
For the other two examples, we again have complex number entries, and computing 
the sum of the absolute value squared of the entries yields 

<br><span style="color:blue;">
他の2つの例でも、複素数の要素があり、要素の絶対値の2乗の合計を計算すると、
</span>

\[
\left|\frac{1}{\sqrt{2}}\right|^2+\left|\frac{1}{\sqrt{2}}\right|^2=\frac{1}{2}+\frac{1}{2}=1
\]

and 

<br><span style="color:blue;">
および
</span>

\[
\left|\frac{1+2i}{3}\right|^2+\left|-\frac{2}{3}\right|^2=\frac{5}{9}+\frac{4}{9}=1
\]

</p><p>
These are therefore valid quantum state vectors. Note that they are linear 
combinations of the standard basis states \(|0\rangle\) and \(|1\rangle\), and for this reason we often 
say that they’re superpositions of the states 0 and 1. Within the context of quantum 
states, superposition and linear combination are essentially synonymous. 

<br><span style="color:blue;">
したがって、これらは有効な量子状態ベクトルです。これらは標準的な基底状態 \(|0\rangle\) と \(|1\rangle\) の線形結合であることに注意してください。このため、これらは状態 0 と 1 の重ね合わせであるとよく言われます。量子状態の文脈では、重ね合わせと線形結合は本質的に同義です。
</span>

</p><p>
The example (1.1) of a qubit state vector above is very commonly encountered — 
it is called the plus state and is denoted as follows: 

<br><span style="color:blue;">
上記の量子ビット状態ベクトルの例（1.1）は非常によく見られるもので、プラス状態と呼ばれ、次のように表されます。
</span>

\[
|+\rangle = \frac{1}{\sqrt{2}}|0\rangle+\frac{1}{\sqrt{2}}|1\rangle
\]

We also use the notation 

<br><span style="color:blue;">
また、次のような表記も使用します
</span>

\[
|-\rangle = \frac{1}{\sqrt{2}}|0\rangle-\frac{1}{\sqrt{2}}|1\rangle
\]

to refer to a related quantum state vector where the second entry is negative rather 
than positive, and we call this state the minus state. 

<br><span style="color:blue;">
関連する量子状態ベクトルの2番目の要素が正ではなく負であるものを指し、この状態をマイナス状態と呼びます。
</span>

</p><p>
This sort of notation, where some symbol other than one referring to a classical 
state appears inside of a ket, is common — we can use whatever name we wish 
inside of a ket to name a vector. It is quite common to use the notation \(|ψ\rangle\), or a 
different name in place of \(ψ\), to refer to an arbitrary vector that may not necessarily 
be a standard basis vector. 

<br><span style="color:blue;">
古典的状態を表す記号以外の記号がケット内に現れるこの種の記法は一般的であり、ケット内ではベクトルに任意の名前を付けることができます。\(|ψ\rangle\) という記法、あるいは \(ψ\) の代わりに別の名前を使って、必ずしも標準的な基底ベクトルではない任意のベクトルを参照することは非常に一般的です。
</span>

</p><p>
Notice that, if we have a vector \(|ψ\rangle\) 
whose indices correspond to some classical 
state set \(Σ\), and if \(a ∈Σ\) 
is an element of this classical state set, then the matrix 
product \(\langle a||ψ\rangle\) 
is equal to the entry of the vector \(|ψ\rangle\) 
whose index corresponds to \(a\). 
As we did when \(|ψ\rangle\) 
was a standard basis vector, we write \(\langle a|ψ\rangle\) 
rather than \8\langle a||ψ\rangle\) 
for the sake of readability. 

<br><span style="color:blue;">
インデックスが何らかの古典的な状態集合 \(Σ\) に対応するベクトル \(|ψ\rangle\) があり、\(a ∈Σ\) がこの古典的な状態集合の要素である場合、行列積 \(\langle a||ψ\rangle\) は、インデックスが \(a\) に対応するベクトル \(|ψ\rangle\) の要素に等しいことに注意してください。\(|ψ\rangle\) が標準的な基底ベクトルであったときと同様に、読みやすさを考慮して、\8\langle a||ψ\rangle\) ではなく \(\langle a|ψ\rangle\) と書きます。
</span>

</p><p>
For example, if \(Σ=\{0, 1\}\) and 

<br><span style="color:blue;">
例えば\(Σ=\{0, 1\}\)と
</span>

\[
|\psi\rangle = \frac{1+2i}{3}|0\rangle-\frac{2}{3}|1\rangle=
\begin{pmatrix}
\frac{1+2i}{3} \\
-\frac{2}{3}
\end{pmatrix}  \tag{1.2}
\]

then 

<br><span style="color:blue;">
そうすると
</span>

\[
\langle 0|\psi\rangle = \frac{1+2i}{3}　and　\langle 1|\psi\rangle=-\frac{2}{3}
\]

</p><p>
In general, when using the Dirac notation for arbitrary vectors, the notation \(\langle ψ|\)
refers to the row vector obtained by taking the conjugate transpose of the column 
vector \(|ψ\rangle\), where the vector is transposed from a column vector to a row vector and each entry is replaced by its complex conjugate. For example, if \(|ψ\rangle\) is the vector defined in (1.2) then 

<br><span style="color:blue;">
一般に、任意のベクトルに対してディラック記法を用いる場合、\(\langle ψ|\) という記法は、列ベクトル \(|ψ\rangle\) の共役転置によって得られる行ベクトルを指す。ここで、ベクトルは列ベクトルから行ベクトルに転置され、各要素はその複素共役に置き換えられる。例えば、\(|ψ\rangle\) が (1.2) で定義されたベクトルである場合、
</span>

\[
\langle\psi|=\frac{1+2i}{3}\langle 0|-\frac{2}{3}\langle 1|=
\begin{pmatrix}
\frac{1+2i}{3} & -\frac{2}{3}
\end{pmatrix}
\]

The reason for taking the complex conjugate, in addition to the transpose, will be 
made more clear later on when we discuss inner products. 

<br><span style="color:blue;">
転置に加えて複素共役をとる理由は、後ほど内積について説明するときにより明確になります。
</span>

</p>

<h3>Quantum states of other systems <span style="color:blue;">他のシステムの量子状態</span></h3>
<p>
We can consider quantum states of systems having arbitrary classical state sets. For 
example, here is a quantum state vector for an electrical fan switch: 

<br><span style="color:blue;">
任意の古典的状態集合を持つシステムの量子状態を考えることができます。例えば、扇風機のスイッチの量子状態ベクトルは次のようになります。
</span>

\[
\begin{pmatrix}
\frac{1}{2} \\
0 \\
-\frac{i}{2} \\
\frac{1}{\sqrt{2}}
\end{pmatrix}
=\frac{1}{2}|high\rangle-\frac{i}{2}|low\rangle+\frac{1}{\sqrt{2}}|off\rangle
\]

The assumption in place here is that the classical states are ordered as high, medium, 
low, off. There may be no particular reason why one would want to consider a 
quantum state of an electrical fan switch, but it is possible in principle. 

<br><span style="color:blue;">
ここでの仮定は、古典的状態が高、中、低、オフの順に並んでいるというものです。電気ファンのスイッチの量子状態を考える特別な理由はないかもしれませんが、原理的には可能です。
</span>

</p><p>
Here’s another example, this time of a quantum decimal digit whose classical 
states are \(0,1,...,9\): 

<br><span style="color:blue;">
ここに別の例を示します。今回は、古典的な状態が \(0,1,...,9\) である量子十進数です。
</span>

\[
\frac{1}{\sqrt{385}}
\begin{pmatrix}
1 \\
2 \\
3 \\
4 \\
5 \\
6 \\
7 \\
8 \\
9 \\
10
\end{pmatrix}
=\frac{1}{\sqrt{385}}\sum_{k=0}^9 (k+1)|k\rangle
\]

This example illustrates the convenience of writing state vectors using the Dirac 
notation. For this particular example, the column vector representation is merely 
cumbersome — but if there were significantly more classical states it would become unusable. The Dirac notation, in contrast, supports precise descriptions of large 
and complicated vectors in a compact form. 

<br><span style="color:blue;">
この例は、ディラック記法を用いて状態ベクトルを記述することの利便性を示しています。この特定の例では、列ベクトル表現は単に扱いにくいだけですが、古典的状態がはるかに多く存在する場合は、使用できなくなります。対照的に、ディラック記法は、大きく複雑なベクトルをコンパクトな形式で正確に記述することをサポートします。
</span>

</p><p>
The Dirac notation also allows for the expression of vectors where different 
aspects of the vectors are indeterminate, meaning that they are unknown or not yet 
established. For example, for an arbitrary classical state set \(Σ\), we can consider the 
quantum state vector 

<br><span style="color:blue;">
ディラック記法は、ベクトルの様々な側面が不確定な、つまり未知であるかまだ確立されていないベクトルの表現も可能にする。例えば、任意の古典状態集合 \(Σ\) に対して、量子状態ベクトルを考えることができる。
</span>

\[
\frac{1}{\sqrt{\Sigma}}\sum_{a\in\Sigma} |a\rangle
\]

where the notation \(|Σ|\) refers to the number of elements in \(Σ\). In words, this is a 
uniform superposition over the classical states in \(Σ\). 

<br><span style="color:blue;">
ここで、\(|Σ|\) という表記は \(Σ\) の要素数を表します。言い換えれば、これは \(Σ\) の古典的状態に対する一様重ね合わせです。
</span>

</p><p>
We’ll encounter much more complicated expressions of quantum state vectors in 
later lessons, where the use of column vectors would be impractical or impossible. In 
fact, we’ll mostly abandon the column vector representation of state vectors, except 
for vectors having a small number of entries (often in the context of examples), 
where it may be helpful to display and examine the entries explicitly. 

<br><span style="color:blue;">
後のレッスンでは、量子状態ベクトルのより複雑な表現に遭遇しますが、列ベクトルの使用は非現実的または不可能です。実際、ここでは状態ベクトルの列ベクトル表現はほとんど使用しません。ただし、要素数が少ないベクトル（多くの場合、例題など）の場合は、要素を明示的に表示して調べることが役立つ場合があります。
</span>

</p><p>
Here’s one more reason why expressing state vectors using the Dirac notation is 
convenient: it alleviates the need to explicitly specify an ordering of the classical 
states (or, equivalently, the correspondence between classical states and vector 
indices). 

<br><span style="color:blue;">
ディラック記法を用いて状態ベクトルを表現することが便利な理由がもう1つあります。それは、古典状態の順序（または、古典状態とベクトルのインデックスの対応）を明示的に指定する必要性が軽減されることです。
</span>

</p><p>
For example, a quantum state vector for a system having classical state set 
{♣, ♢, ♡, ♠}, such as 

<br><span style="color:blue;">
例えば、古典状態集合{♣, ♢, ♡, ♠}を持つシステムの量子状態ベクトルは、
</span>

\[
\frac{1}{2}|♣\rangle+\frac{i}{2}|♢\rangle-\frac{1}{2}|♡\rangle-\frac{i}{2}|♠\rangle
\]

is described by this expression without ambiguity, and there’s really no need to 
choose or specify an ordering of this classical state set to make sense of the expression. 
In this case, it’s not difficult to specify an ordering of the standard card suits — 
for instance, we might choose to order them like this: ♣, ♢, ♡, ♠. If we choose this 
particular ordering, the quantum state vector above would be represented by the column vector 

<br><span style="color:blue;">
は、この式によって曖昧さなく記述され、この式を理解するためにこの古典的な状態集合の順序を選択したり指定したりする必要はまったくありません。
この場合、標準的なカードのスーツの順序を指定することは難しくありません。
例えば、♣、♢、♡、♠のように順序付けることができます。この特定の順序付けを選択した場合、上記の量子状態ベクトルは列ベクトルで表されます。
</span>

\[
\begin{pmatrix}
\frac{1}{2} \\
\frac{i}{2} \\
-\frac{1}{2} \\
-\frac{i}{2}
\end{pmatrix}
\]


In general, however, it is convenient to be able to simply ignore the issue of how classical state sets are ordered. 

<br><span style="color:blue;">
ただし、一般的には、古典的な状態セットがどのように順序付けられるかという問題を単に無視できる方が便利です。
</span>

</p>

<h3>Measuring quantum states <span style="color:blue;">量子状態の測定</span></h3>
<p>

Next let us consider what happens when a quantum state is measured, focusing on a 
simple type of measurement known as a standard basis measurement. There are more 
general notions of measurement that we’ll discuss later on. 

<br><span style="color:blue;">
次に、量子状態を測定すると何が起こるかを考えてみましょう。ここでは、標準基底測定と呼ばれる単純なタイプの測定に焦点を当てます。測定に関するより一般的な概念については、後ほど説明します。
</span>

</p><p>
Similar to the probabilistic setting, when a system in a quantum state is measured, 
the hypothetical observer performing the measurement won’t see a quantum 
state vector, but rather will see some classical state. In this sense, measurements act 
as an interface between quantum and classical information, through which classical 
information is extracted from quantum states. 

<br><span style="color:blue;">
確率論的な設定と同様に、量子状態にある系を測定する場合、測定を行う仮想的な観測者は量子状態ベクトルではなく、何らかの古典状態を観測することになります。この意味で、測定は量子情報と古典情報の間のインターフェースとして機能し、それを通して量子状態から古典情報が抽出されます。
</span>

</p><p>
The rule is simple: if a quantum state is measured, each classical state of the 
system appears with probability equal to the absolute value squared of the entry in the 
quantum state vector corresponding to that classical state. This is known as the Born 
rule in quantum mechanics. Notice that this rule is consistent with the requirement 
that the absolute values squared of the entries in a quantum state vector sum to 1, 
as it implies that the probabilities of different classical state measurement outcomes 
sum to 1. 

<br><span style="color:blue;">
規則は単純です。量子状態を測定すると、システムの各古典状態は、その古典状態に対応する量子状態ベクトルの要素の絶対値の2乗に等しい確率で出現します。これは量子力学ではボルン則として知られています。この規則は、量子状態ベクトルの要素の絶対値の2乗の合計が1になるという要件と整合していることに注意してください。これは、異なる古典状態測定結果の確率の合計が1になることを意味します。
</span>

</p><p>
For example, measuring the plus state 

<br><span style="color:blue;">
例えば、プラスの状態を測定する
</span>

\[
|+\rangle = \frac{1}{\sqrt{2}}|0\rangle+\frac{1}{\sqrt{2}}|1\rangle
\]

results in the two possible outcomes, 0 and 1, with probabilities as follows. 

<br><span style="color:blue;">
0と1の2つの結果が起こり、その確率は次のようになります。
</span>

\[
\begin{align}
Pr(outcome\;is\; 0) &= \left|\langle 0|+\rangle\right|^2
=\left|\frac{1}{\sqrt{2}}\right|^2=\frac{1}{2} \\
\\
Pr(outcome\;is\;1) &=\left|\langle 1|+\rangle\right|^2=\left|\frac{1}{\sqrt{2}}\right|^2=\frac{1}{2}
\end{align}
\]

Interestingly, measuring the minus state 

<br><span style="color:blue;">
興味深いことに、マイナスの状態を測定すると
</span>

\[
|-\rangle=\frac{1}{\sqrt{2}}|0\rangle-\frac{1}{\sqrt{2}}|1\rangle
\]

results in exactly the same probabilities for the two outcomes. 

<br><span style="color:blue;">
2 つの結果の確率はまったく同じになります。
</span>

\[
\begin{align}
Pr(outcome\;is\; 0) &= \left|\langle 0|-\rangle\right|^2
=\left|\frac{1}{\sqrt{2}}\right|^2=\frac{1}{2} \\
\\
Pr(outcome\;is\;1) &=\left|\langle 1|-\rangle\right|^2=\left|-\frac{1}{\sqrt{2}}\right|^2=\frac{1}{2}
\end{align}
\]

This suggests that, as far as standard basis measurements are concerned, the plus 
and minus states are no different. Why, then, would we care to make a distinction 
between them? The answer is that these two states behave differently when 
operations are performed on them, as we will discuss in the next subsection below. 

<br><span style="color:blue;">
これは、標準的な基底測定に関する限り、プラスの状態とマイナスの状態には違いがないことを示唆しています。では、なぜ両者を区別する必要があるのでしょうか？その答えは、次の節で説明するように、これら2つの状態は操作を行った際に異なる挙動を示すからです。
</span>

</p><p>
Of course, measuring the quantum state \(|0\rangle\) 
results in the classical state 0 with 
certainty, and likewise measuring the quantum state \|1\ranglr\) 
results in the classical 
state 1 with certainty. This is consistent with the identification of these quantum 
states with the system being in the corresponding classical state, as was suggested 
previously. 

<br><span style="color:blue;">
もちろん、量子状態 \(|0\rangle\) を測定すると、古典状態 0 が確実に得られ、同様に量子状態 \|1\ranglr\) を測定すると、古典状態 1 が確実に得られます。これは、以前に示唆されたように、これらの量子状態が、系が対応する古典状態にあることと一致するという考え方と整合しています。
</span>

</p><p>
As a final example, measuring the state 

<br><span style="color:blue;">
最後の例として、状態を測定する
</span>

\[
|\psi\rangle = \frac{1+2i}{3}|0\rangle - \frac{2}{3}|1\rangle
\]

causes the two possible outcomes to appear with probabilities as follows: 

<br><span style="color:blue;">
2 つの可能な結果が次の確率で発生します。
</span>

\[
Pr(outcome\;is\;0)=\left|\langle 0|\psi\rangle\right|^2=\left|\frac{1+2i}{3}\right|^2=\frac{5}{9}
\]

and 

<br><span style="color:blue;">
および
</span>

\[
Pr(outcome\;is\;1)=\left|\langle 1|\psi\rangle\right|^2=\left|-\frac{2}{3}\right|^2=\frac{4}{9}
\]

</p>

<h3>Unitary operations <span style="color:blue;">ユニタリ演算</span></h3>

<p>
Thus far, it may not be evident why quantum information is fundamentally different 
from classical information. That is, when a quantum state is measured, the 
probability to obtain each classical state is given by the absolute value squared of 
the corresponding vector entry — so why not simply record these probabilities in a 
probability vector? 

<br><span style="color:blue;">
これまでのところ、量子情報が古典情報と根本的に異なる理由は明らかではないかもしれません。つまり、量子状態を測定する際、各古典状態を得る確率は、対応するベクトル要素の絶対値の2乗で与えられます。では、なぜこれらの確率を確率ベクトルに記録しないのでしょうか？
</span>

</p><p>
The answer, at least in part, is that the set of allowable operations that can be 
performed on a quantum state is different than it is for classical information. Similar 
to the probabilistic setting, operations on quantum states are linear mappings — 
but rather than being represented by stochastic matrices, like in the classical case, 
operations on quantum state vectors are represented by unitary matrices. 

<br><span style="color:blue;">
答えは、少なくとも部分的には、量子状態に対して実行可能な演算の集合が、古典情報の場合とは異なるということです。確率的設定と同様に、量子状態に対する演算は線形写像ですが、古典情報の場合のように確率行列で表されるのではなく、量子状態ベクトルに対する演算はユニタリ行列で表されます。
</span>

</p><p>
A square matrix \(\mathcal{U}\) having complex number entries is unitary if it satisfies the 
following two equations. 

<br><span style="color:blue;">
複素数要素を持つ正方行列 \(\mathcal{U}\) がユニタリ行列であるとは、次の2つの式を満たす場合に言います。
</span>

\[
\begin{align}
\mathcal{UU}^\dagger &= \mathbb{I} \\
\\
\mathcal{U}^\dagger\mathcal{U} &= \mathbb{I}
\end{align}
\tag{1.3}
\]
 
Here, \(\mathbb{I}\) is the identity matrix, and \(\mathcal{U}^†\) is the conjugate transpose of \mathcal{U}\), meaning the 
matrix obtained by transposing \(\mathcal{U}\) and taking the complex conjugate of each entry. 

<br><span style="color:blue;">
ここで、\(\mathbb{I}\) は単位行列、\(\mathcal{U}^†\) は \mathcal{U}\) の共役転置行列です。つまり、\(\mathcal{U}\) を転置し、各要素の複素共役をとることで得られる行列です。
</span>

\[
\mathcal{U}^† = \overline{\mathcal{U^T}}
\]
 
If either of the two equalities numbered (1.3) above is true, then the other must also 
be true. Both equalities are equivalent to \(\mathcal{U}^†\) being the inverse of \(\mathcal{U}\): 

<br><span style="color:blue;">
上記(1.3)の2つの等式のいずれかが真であれば、もう一方も真でなければならない。どちらの等式も、\(\mathcal{U}^†\) が \(\mathcal{U}\) の逆であることと等しい。
</span>

\[
\mathcal{U}^{−1} = \mathcal{U}^† 
\]

(Warning: if \(M\) is not a square matrix, then it could be that \(M^†M = \mathbb{I}\) while \(MM^† \neq \mathbb{I}\), for instance. The equivalence of the two equalities (1.3) is only true for 
square matrices.) 

<br><span style="color:blue;">
（注意：\(M\)が正方行列でない場合、例えば\(M^†M = \mathbb{I}\)であるのに\(MM^† \neq \mathbb{I}\)となる可能性があります。2つの等式（1.3）の同値性は正方行列の場合にのみ当てはまります。）
</span>

</p><p>
The condition that \(\mathcal{U}\) is unitary is equivalent to the condition that multiplication 
by \(\mathcal{U}\) does not change the Euclidean norm of any vector. That is, an \(n × n\) matrix \(\mathcal{U}\) 
is unitary if and only if \(||\mathcal{U}|ψ\rangle||=|| |ψ\rangle||\) 
for every n-dimensional column vector \(|ψ\rangle\) 
with complex number entries. Thus, because the set of all quantum state vectors 
is the same as the set of vectors having Euclidean norm equal to 1, multiplying a 
unitary matrix to a quantum state vector results in another quantum state vector. 

<br><span style="color:blue;">
\(\mathcal{U}\) がユニタリ行列であるという条件は、\(\mathcal{U}\) を掛けてもどのベクトルのユークリッドノルムも変化しないという条件と同等です。つまり、\(n × n\) 行列 \(\mathcal{U}\) がユニタリ行列であるためには、複素数要素を持つすべての n 次元列ベクトル \(|ψ\rangle\) に対して \(||\mathcal{U}|ψ\rangle||=|| |ψ\rangle||\) が成立する必要があります。したがって、すべての量子状態ベクトルの集合は、ユークリッドノルムが 1 であるベクトルの集合と同じであるため、ユニタリ行列を量子状態ベクトルに掛けると、別の量子状態ベクトルが得られます。
</span>

</p><p>
Indeed, unitary matrices represent exactly the set of linear mappings that always 
transform quantum state vectors to quantum state vectors. Notice here a 
resemblance to the classical probabilistic case where operations are associated with 
stochastic matrices, which are the ones that always transform probability vectors 
into probability vectors. 

<br><span style="color:blue;">
実際、ユニタリ行列は、量子状態ベクトルを常に量子状態ベクトルに変換する線形写像の集合を正確に表しています。ここで、演算が確率行列に関連付けられている古典的な確率論的ケースとの類似性に注目してください。確率行列は常に確率ベクトルを確率ベクトルに変換します。
</span>

</p>

<h3>Examples of unitary operations on qubits <span style="color:blue;">量子ビットのユニタリ演算の例</span></h3>
<p>
The following list describes some commonly encountered unitary operations on 
qubits. 

<br><span style="color:blue;">
以下のリストは、量子ビット上でよく見られるユニタリ演算の一部を示しています。
</span>

</p><p>
<strong>Pauli operations.</strong>　The four Pauli matrices are as follows: 

<br><span style="color:blue;">
<strong>パウリ演算</strong> 4 つのパウリ行列は次のとおりです。
</span>

\[
\mathbb{I}=
\begin{pmatrix}
1 & 0 \\
0 & 1
\end{pmatrix}
,　\sigma_x=
\begin{pmatrix}
0 & 1 \\
1 & 0
\end{pmatrix}
,　\sigma_y=
\begin{pmatrix}
0 & -i \\
i & 0
\end{pmatrix}
,　\sigma_z=
\begin{pmatrix}
1 & 0 \\
0 & -1
\end{pmatrix}
\]

A common alternative notation is \(X = σ_x, Y =σ_y,\) and \(Z =σ_z\) (but be aware that the 
letters \(X, Y,\) and \(Z\) are also commonly used for other purposes). The \(X\) operation is 
also called a bit-flip or a NOT operation because it induces this action on bits: 

<br><span style="color:blue;">
一般的な代替表記は \(X = σ_x, Y =σ_y,\) および \(Z =σ_z\) です（ただし、文字 \(X, Y,\) および \(Z\) は他の目的でもよく使用されることに注意してください）。\(X\) 演算は、ビットに対して次の動作を誘発するため、ビット反転または NOT 演算とも呼ばれます。
</span>

\[
X|0\rangle = |1\rangle　and　X|1\rangle = |0\rangle
\] 

The \(Z\) operation is also called a phase-flip, and it has this action: 

<br><span style="color:blue;">
\(Z\) 演算は位相反転とも呼ばれ、次のような動作をします。
</span>

\[
Z|0\rangle = |0\rangle　and　Z|1\rangle = −|1\rangle
\]

<strong>Hadamard operation.</strong> The Hadamard operation is described by this matrix: 

<br><span style="color:blue;">
<strong>アダマール演算</strong> アダマール演算は次の行列で記述されます。
</span>

\[
H = 
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix}
\]

<strong>Phase operations.</strong> A phase operation is one described by the matrix 

<br><span style="color:blue;">
<strong>位相演算</strong>位相演算は行列で記述される演算である。
</span>

\[
P_\theta =
\begin{pmatrix}
1 & 0 \\
0 & e^{i\theta}
\end{pmatrix}
\]

for any choice of a real number \(θ\). The operations 

<br><span style="color:blue;">
実数\(θ\)の任意の選択に対して、演算は
</span>

\[
S = P_{\pi/2}=
\begin{pmatrix}
1 & 0 \\
0 & i
\end{pmatrix}
　and　T = P_{π/4} = 
\begin{pmatrix}
1 & 0 \\
0 & \frac{1+i}{\sqrt{2}}
\end{pmatrix}
\]

are particularly important examples. Other examples include \(\mathbb{I} 
= P_0\) and \(Z = P_π\). 

<br><span style="color:blue;">
は特に重要な例です。他の例としては、\(\mathbb{I}
= P_0\) や \(Z = P_π\) などがあります。
</span>

</p><p>
All of the matrices just defined are unitary, and therefore represent quantum 
operations on a single qubit. For example, here is a calculation that verifies that \(H\) 
is unitary: 

<br><span style="color:blue;">
今定義した行列はすべてユニタリ行列であり、したがって単一量子ビットに対する量子演算を表します。例えば、\(H\) がユニタリ行列であることを確認する計算は次のとおりです。
</span>

\[
\begin{align}
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix}^\dagger
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix}
&=
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix}
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix} \\
\\
&=
\begin{pmatrix}
\frac{1}{2}+\frac{1}{2} & \frac{1}{2}-\frac{1}{2} \\
\frac{1}{2}-\frac{1}{2} & \frac{1}{2}+\frac{1}{2}
\end{pmatrix}
=
\begin{pmatrix}
1 & 0 \\
0 & 1
\end{pmatrix}
\end{align}
\]

And here’s the action of the Hadamard operation on a few commonly encountered qubit state vectors. 

<br><span style="color:blue;">
以下は、よく見られるいくつかの量子ビット状態ベクトルに対するアダマール演算の作用です。
</span>

\[
\begin{align}
H|0\rangle &= 
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix}
\begin{pmatrix}
1 \\
0
\end{pmatrix}
=
\begin{pmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{pmatrix}
=|+\rangle \\
\\
H|1\rangle &= 
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix}
\begin{pmatrix}
0 \\
1
\end{pmatrix}
=
\begin{pmatrix}
\frac{1}{\sqrt{2}} \\
-\frac{1}{\sqrt{2}}
\end{pmatrix}
=|-\rangle \\
\\
H|+\rangle &=
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix}
\begin{pmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{pmatrix}
=
\begin{pmatrix}
1 \\
0
\end{pmatrix}
=|0\rangle \\
\\
H|-\rangle &=
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix}
\begin{pmatrix}
\frac{1}{\sqrt{2}} \\
-\frac{1}{\sqrt{2}}
\end{pmatrix}
=
\begin{pmatrix}
0 \\
1
\end{pmatrix}
=|1\rangle 
\end{align}
\]

More succinctly, we obtain these four equations. 

<br><span style="color:blue;">
もっと簡潔に言うと、次の 4 つの方程式が得られます。
</span>

\[
\begin{align}
&H|0\rangle = |+\rangle　H|+\rangle = |0\rangle \\
\\
&H|1\rangle = |−\rangle　H|−\rangle = |1\rangle
\end{align}
\] 

</p><p>
It’s worth pausing to consider the fact that \(H|+\rangle = |0\rangle\) 
and \(H|−\rangle = |1\rangle\), in light of the question suggested in the previous section concerning the distinction 
between the states \(|+\rangle\) and \(|−\rangle\). 

<br><span style="color:blue;">
前のセクションで提起された状態 \(|+\rangle\) と \(|−\rangle\) の区別に関する疑問を踏まえて、\(H|+\rangle = |0\rangle\)
および \(H|−\rangle = |1\rangle\) という事実について考察する価値があります。
</span>

</p><p>
Imagine a situation in which a qubit is prepared in one of the two quantum states \(|+\rangle\) and \(|−\rangle\), but where it is not known to us which one it is. Measuring either 
state produces the same output distribution as the other, as we already observed: 
0 and 1 both appear with equal probability 1/2, which provides no information 
whatsoever about which of the two states was prepared. 

<br><span style="color:blue;">
量子ビットが2つの量子状態 \(|+\rangle\) と \(|−\rangle\) のいずれかに準備されているが、どちらの状態であるかは不明な状況を想像してみてください。どちらの状態を測定しても、既に観察したように、もう一方と同じ出力分布が生成されます。0と1はどちらも同じ確率 1/2 で出現しますが、どちらの状態が準備されているかについては全く情報が得られません。
</span>

</p><p>
However, if we first apply a Hadamard operation and then measure, we obtain 
the outcome 0 with certainty if the original state was \(|+\rangle\), and we obtain the outcome 
1, again with certainty, if the original state was \(|−\rangle\). The quantum states \(|+\rangle\) and \(|−\rangle\) can therefore be discriminated perfectly. This reveals that sign changes, or more 
generally changes to the phases (which are also traditionally called arguments) of the 
complex number entries of a quantum state vector, can significantly change that 
state. 

<br><span style="color:blue;">
しかし、まずアダマール演算を適用してから測定すると、元の状態が \(|+\rangle\) であれば確実に結果 0 が得られ、元の状態が \(|−\rangle\) であれば、やはり確実に結果 1 が得られます。したがって、量子状態 \(|+\rangle\) と \(|−\rangle\) は完全に識別できます。これは、量子状態ベクトルの複素数要素の符号の変化、あるいはより一般的には位相（伝統的には引数とも呼ばれる）の変化によって、その状態が大きく変化する可能性があることを示しています。
</span>

</p><p>
Here’s another example, showing how a Hadamard operation acts on a state 
vector that was mentioned previously. 

<br><span style="color:blue;">
ここに、先ほど述べた状態ベクトルに対してアダマール演算がどのように作用するかを示す別の例を示します。
</span>

\[
\begin{align}
H\left(\frac{1+2i}{3}|0\rangle-\frac{2}{3}|1\rangle\right)&=
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix}
\begin{pmatrix}
\frac{1+2i}{3} \\
-\frac{2}{3}
\end{pmatrix}
=
\begin{pmatrix}
\frac{-1+2i}{3\sqrt{2}} \\
\frac{3+2i}{3\sqrt{2}}
\end{pmatrix} \\
\\
&=\frac{-1+2i}{3\sqrt{2}}|0\rangle+\frac{3+2i}{3\sqrt{2}}|1\rangle
\end{align}
\]

Next, let’s consider the action of a \(T\) operation on a plus state. 

<br><span style="color:blue;">
次に、プラス状態に対する \(T\) 演算のアクションを考えてみましょう。
</span>

\[
T|+\rangle = T\left(\frac{1}{\sqrt{2}}|0\rangle+\frac{1}{\sqrt{2}}|1\rangle\right)=\frac{1}{\sqrt{2}}T|0\rangle+\frac{1}{\sqrt{2}}T|1\rangle
=\frac{1}{\sqrt{2}}|0\rangle+\frac{1+i}{2}|1\rangle
\]

Notice here that we did not bother to convert to the equivalent matrix/vector forms, 
and instead used the linearity of matrix multiplication together with the formulas 

<br><span style="color:blue;">
ここで注意すべきは、等価な行列/ベクトル形式への変換をせず、代わりに行列乗算の線形性と式を併用した点である。
</span>

\[
T|0\rangle = |0\rangle　and　T|1\rangle = \frac{1+i}{\sqrt{2}}|1\rangle
\]
 
Along similar lines, we may compute the result of applying a Hadamard operation 
to the quantum state vector just obtained. 

<br><span style="color:blue;">
同様に、得られた量子状態ベクトルにアダマール演算を適用した結果を計算することもできる。
</span>

\[
\begin{align}
H\left(\frac{1}{\sqrt{2}}|0\rangle+\frac{1+i}{2}|1\rangle\right)
&=\frac{1}{\sqrt{2}}H|0\rangle + \frac{1+i}{2}H|1\rangle \\
\\
&= \frac{1}{\sqrt{2}}|+\rangle+\frac{1+i}{2}|-\rangle \\
\\
&=\left(\frac{1}{2}|0\rangle+\frac{1}{2}|1\rangle\right)+\left(\frac{1+i}{2\sqrt{2}}|0\rangle-\frac{1+i}{2\sqrt{2}}~1\rangle\right) \\
\\
&=\left(\frac{1}{2}+\frac{1+i}{2\sqrt{2}}\right)|0\rangle+\left(\frac{1}{2}-\frac{1+i}{2\sqrt{2}}\right)|1\rangle
\end{align}
\]

</p><p>
The two approaches — one where we explicitly convert to matrix representations 
and the other where we use linearity and plug in the actions of an operation 
on standard basis states — are equivalent. We can use whichever one is more 
convenient in the case at hand. 

<br><span style="color:blue;">
2つのアプローチ、つまり明示的に行列表現に変換する方法と、線形性を利用して標準的な基底状態における演算のアクションを代入する方法は同等です。それぞれのケースにおいて、より都合の良い方を使用することができます。
</span>

</p>

<h3>Compositions of qubit unitary operations <span style="color:blue;">量子ビットユニタリ演算の構成</span></h3>
<p>
Compositions of unitary operations are represented by matrix multiplication, just 
like we had in the probabilistic setting. 

<br><span style="color:blue;">
ユニタリ演算の合成は、確率的設定の場合と同様に、行列の乗算によって表されます。
</span>

</p><p>
For example, suppose we first apply a Hadamard operation, followed by an 
S operation, followed by another Hadamard operation. The resulting operation, 
which we shall name R for the sake of this example, is as follows. 

<br><span style="color:blue;">
例えば、最初にアダマール演算を適用し、続いてS演算を適用し、さらに別のアダマール演算を適用するとします。結果として得られる演算（この例ではRと名付けます）は以下のようになります。
</span>

\[
R = HSH =
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix} 
\begin{pmatrix}
1 & 0 \\
0 & i
\end{pmatrix} 
\begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix} 
=
\begin{pmatrix}
\frac{1+i}{2} & \frac{1-i}{2} \\
\frac{1-i}{2} & \frac{1+i}{2}
\end{pmatrix} 
\]

This unitary operation R is an interesting example. By applying this operation 
twice, which is equivalent to squaring its matrix representation, we obtain a NOT operation:

<br><span style="color:blue;">
このユニタリ演算Rは興味深い例です。この演算を2回適用すると（これは行列表現を2乗することと同等です）、NOT演算が得られます。
</span>

\[
R^2 = 
\begin{pmatrix}
\frac{1+i}{2} & \frac{1-i}{2} \\
\frac{1-i}{2} & \frac{1+i}{2}
\end{pmatrix}^2=
\begin{pmatrix}
0 & 1 \\
1 & 0
\end{pmatrix}
\]
 
That is, \(R\) is a square root of NOT operation. Such a behavior, where the same 
operation is applied twice to yield a NOT operation, is not possible for a classical 
operation on a single bit. 

<br><span style="color:blue;">
つまり、\(R\) は NOT 演算の平方根です。同じ演算を 2 回適用して NOT 演算を生成するこのような動作は、単一ビットに対する従来の演算では不可能です。
</span>

</p>

<h3>Unitary operations on larger systems <span style="color:blue;">大規模システムにおけるユニタリ操作</span></h3>
<p>
In subsequent lessons, we will see many examples of unitary operations on systems 
having more than two classical states. An example of a unitary operation on a 
system having three classical states is given by the following matrix. 

<br><span style="color:blue;">
以降のレッスンでは、2つ以上の古典状態を持つ系におけるユニタリ演算の例を数多く見ていきます。3つの古典状態を持つ系におけるユニタリ演算の例は、次の行列で示されます。
</span>

\[
A =
\begin{pmatrix}
0 & 0 & 1 \\
1 & 0 & 0 \\ 
0 & 1 & 0
\end{pmatrix}
\]

Assuming that the classical states of the system are 0, 1, and 2, we can describe this 
operation as addition modulo 3. 

<br><span style="color:blue;">
システムの古典的状態が0、1、2であると仮定すると、この操作は3を法とする加算として記述できます。
</span>

\[
A|0⟩ = |1⟩,　A|1⟩ = |2⟩,　and　A|2⟩ = |0⟩ 
\]

</p><p>
The matrix \(A\) is an example of a permutation matrix, which is a matrix in which 
every row and column has exactly one 1, with all other entries being 0. Such 
matrices merely rearrange, or permute, the entries of the vectors they act upon. 
The identity matrix is perhaps the simplest example of a permutation matrix, and 
another example is the NOT operation on a bit or qubit. Every permutation matrix, 
in any positive integer dimension, is unitary. These are the only examples of 
matrices that represent both classical and quantum operations: a matrix is both 
stochastic and unitary if and only if it is a permutation matrix. 

<br><span style="color:blue;">
行列 \(A\) は、すべての行と列にちょうど 1 が 1 つ含まれ、その他のすべての要素が 0 であるような行列である、順列行列の例です。このような行列は、作用するベクトルの要素を単に並べ替える、つまり入れ替えるだけです。単位行列は、おそらく順列行列の最も単純な例であり、ビットまたは量子ビットに対する NOT 演算もその 1 つです。任意の正の整数次元におけるすべての順列行列は、ユニタリです。これらは、古典的演算と量子演算の両方を表す行列の唯一の例です。つまり、行列が確率的かつユニタリであるためには、それが順列行列である必要があります。
</span>

</p><p>
Another example of a unitary matrix, this time being a 4 × 4 matrix, is this one: 

<br><span style="color:blue;">
ユニタリ行列の別の例（今回は 4 × 4 行列）は次のとおりです。
</span>

\[
\mathcal{U}=\frac{1}{2}
\begin{pmatrix}
1 & 1 & 1 & 1 \\
1 & i & -1 & -i \\
1 & -1 & 1 & -1 \\
1 & -i & -1 & i
\end{pmatrix}
\]

This matrix describes an operation known as the quantum Fourier transform, specifically 
in the 4 × 
4 case. The quantum Fourier transform can be defined more 
generally, for any positive integer dimension, and plays a key role in quantum 
algorithms. 

<br><span style="color:blue;">
この行列は、量子フーリエ変換と呼ばれる演算、特に4×4の場合の演算を記述します。量子フーリエ変換はより一般的に、任意の正の整数次元に対して定義することができ、量子アルゴリズムにおいて重要な役割を果たします。
</span>

</p>
    </body>
</html>